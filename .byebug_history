c
params
permitted_checkout_attributes[5][:payments_attributes]
permitted_checkout_attributes[5]
permitted_checkout_attributes[6]
permitted_checkout_attributes
c
@updating_params[:order][:payments_attributes].first[:amount]
@updating_params[:order][:payments_attributes].first[amont]
@updating_params[:order][:payments_attributes].first
c
@updating_params[:order][:payments_attributes].first
@updating_params[:order][:payments_attributes]
@updating_params
c
permitted_checkout_attributes[5][:payments_attributes]
permitted_checkout_attributes[5]
params
permitted_checkout_attributes[:payments_attributes]
permitted_checkout_attributes
c
order.bill_address
order.ship_address
order
c
ship_method.include?(order.ship_address)
c
ship_method.include?(order.ship_address)
c
ship_method.include?(order.ship_address)
c
ship_method.include?(order.ship_address)
calculator.available?(package)
ship_method
order.bill_address
order.ship_address
c
package.shipping_methods
package.shipping_methods.first.calculator
package.shipping_methods.count
package.shipping_methods
ui_filter
package
shipping_methods(package, ui_filter)
c
shipments.first.shipping_rates
shipments.first
shipments.count
shipments.any? { |shipment| shipment.shipping_rates.blank? }
shipments
c
n
self.shipments.first.persisted?
self.shipments.first
self.shipments
c
shipments
c
@order.line_items
@order
c
@order
self.order
self
c
@order.changes
@order.bill_address.first_name
@order.bill_address
@order
c
respond_to?(method_name, true)
c
params
@order.email
@order.bill_address
@order.state
@order
c
n
c
@order.email
@order
params[:checkout][:order] == params[:order]
params[:checkout][:order]
params[:checkout]
params
c
respond_to?(method_name, true)
c
nested_params
params
para,s
@order.bill_address
@order
n
args
n
env.halted
n
order
@order
result
target
n
@order.bill_address
respond_to?(:before_delivery, true)
respond_to?(method_name, true)
method_name
c
@order
n
@order.state
@order.insufficient_stock_lines.present?
Spree::Order.lock(true).find_by!(number: params[:id])
Spree::Order.lock(lock).find_by!(number: params[:id])
params[:id]
params[:state]
params
@order.valid?
@order.bill_address
@order.ship_address
@order.address
@order.changes
@order
c
@order.shipments
n
import_params
c
params[:order][:shipments]
c
self.shipments
self.state
c
self.shipments.first.persisted?
self.shipments
self.changes
shipments.first
shipments
shipments.any?
c
shipments.any?
shipments.any? && !self.completed?
c
order.shipments
n
order.reload.state
n
order.reload.state
c
order.reload.state
c
order.reload.state
order.changes
order.state
c
n
c
order.state
order.stater
c
n
current_api_user.can?(:update, @order)
current_api_user
current_user
authorize! :update, @order, order_token
c
requires_authentication? && api_key.blank? && order_token.blank?
order_token.blank? && (requires_authentication? || api_key.present?)
c
order_token.blank? && (requires_authentication? || api_key.present?)
requires_authentication? && api_key.blank? && order_token.blank?
c
@current_api_user
c
exception
n
c
order_token.blank? && (requires_authentication? || api_key.present?)
api_key
requires_authentication?
c
Spree::Api::Config[:requires_authentication]
requires_authentication?
c
requires_authentication?
requires_authentication
c
order.contents.add({})
line_item_params
line_item_params[:options]
n
c
params
params[:line_item]
params[:line_items]
params[:line_item]
params[:line_item][:variant_id]
